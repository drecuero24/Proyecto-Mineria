---
title: "Memoria Mineria"
author: "Daniel/  Sergio"
date: "1/10/2021"
output: bookdown::gitbook
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción

Los datos que se van a tratar en este informe están relacionados con campañas de marketing directo, más concretamente a través de llamadas telefónicas, que una institución bancaria portuguesa realizó años atrás.

#####La base de datos fue publicada el 14 de Febrero de 2012. Hay que tener en cuenta que............ NO SE Si EXPLICAR LAS CUATRO BASES DE DATOS QUE NOS DIERON Hubo más de un contacto con ciertos clientes

#####NO SE SI PONER ES TO AQUí El objetivo de este informe es crear un modelo capaz de predecir si el cliente se suscribirá o no al producto que oferecía el banco, un depoósito a plazo bancario. La variable encargada de recoger esta información, es decir, la variable respuesta, es la variable 'y'.

A continuación, damos nombre a las variables y una breve explicación de la información que aportan, incluyendo la tipología de dicha variable:

Nombre | Descripción
----------------|------------
**1** AGE |     Edad del cliente contactado por el banco. Variable numérica entera.
**2** JOB |     Profesión realizada por el cliente contactado (en la sección "datos" veremos los valores posible de la variable). Variable categórica.
**3** MARITAL | Estado civil del cliente contactado (soltero, casado , divorciado o viudo(se engloban en la misma variable con el nombre de "divorciado") o desconocido). Variable categórica. 
**4** EDUCATION | Título de estudios superior que posee el cliente contactado (3 niveles básicos de enseñanza, escuela secundaria, formación profesional, estudios universitarios o sin estudios.) Variable categórica.
**5** DEFAULT | Si el cliente tiene o no un crèdito en inclumplimiento (sí, no , desconocido). Variable categórica.
**6** HOUSING | Si el cliente tiene un préstamo para pagar su vivienda (sí, no , desconocido). Variable categórica.
**7** LOAN | Si el cliente tiene o no un préstamo personal (sí, no, desconocido). Variable categórica.
**8** CONTACT | Modo de contacto del banco con el cliente(móvil,teléfono fijo). Variable categórica
**9** MONTH | Último mes del año en el que el banco contactó con el cliente. Variable categórica.
**10** DAY_OF_WEEK | Último día de la semana en el que en banco contactó con el cliente. Variable categórica.
**11** DURATION | Duración del último contacto del banco con el cliente en segundos. Variable numérica.
**12** CAMPAIGN | Número de contactos realizados al cliente durante la campaña actual hasta el momento. Variable numérica entera.
**13** PDAYS | Número de días desde que el cliente fue contactado por última vez en una campaña anterior. Variable numérica entera.
**14** PREVIOUS | Número de contactos realizados previos a la campaña actual para cada cliente. Variable numérica entera.
**15** POUTCOME | Resultado de la campaña de marketing anterior (éxito, fracaso, inexistente). Variable categórica
**16** EMP.VAR.RATE | Tasa de variación de empleo en un periodo de tres meses. Variable numérica.
**17** CONS.PRIDE.IDX | Índice de precios al consumidor mensualmente. Variable numérica.
**18** CONS.CONF.IDX | Índice de confianza del consumidor mensualmente. Variable numérica.
**19** EURIBOR3M | Tasa de Euríbor a 3 meses medido diariamente. Variable numérica.
**20** NR.EMPLOYED | Cómo ha variado el número de empleados del banco en un periodo de 3 meses. Variable numérica entera.

Las siete primeras variables están relacionadas con información personal de cada cliente, las siguientes cuatro con el contacto en la campaña actual y las demás son variables relacionadas con otros aspectos como el contexto social y económico actual y las campañas pasadas.

Antes de cerrar esta sección, se carga la base de datos y las librerías que se van a emplear a lo largo del informe:
```{r apertura, echo=FALSE}
setwd("C:/Users/danir/OneDrive/Escritorio/Mineria de datos/bank-additional")
dataSet<- read.csv("bank-additional-full.csv",header=TRUE,sep = ";",dec = ".")
```

```{r librerias}
library(ggplot2) #Gráficos
```

## Particiones y cambio de tipo de variable

En este apartado, dividimos el conjunto de datos en 3 subconjuntos que nos servirán para realizar las tareas posteriores. En primer lugar, los datos de entrenamiento suponen el 10% de los datos totales, cuya finalidad será utilizarlos para tratar y aplicar las técnicas de ciencia de datos con el fin de crear el modelo. Seguidamente, los datos de prueba, otro 10% de los datos totales,  son los datos a través de los cuales se probará que las técnicas empleadas funcionan y el moedlo final es válido. Por último, los datos de validación, el conjunto con mayor cantidad de información, servirán para poder mostrar que todo  el trabajo realizado previamente funciona como debería.


Aqui cambiamos la variables para faacilitar plots:default porque en ek DAA hemos visto que sería bueno representarla correctamente.
job: 0unknow 1admin. 2blue-collar 3entrepreneur 4housemaid 5management 6retired 7self-employed 8services 9student
      10technician 11unemployed
marital: 0 unknow 1divorced 2married 3single    
education: 0unknown 1basic.4y 2.basic.6y 3basic.9y 4high.school 5illiterate 6 professional.course 7university.degree
default: 0unknow 1NO, 2 yes
housing 0 unknow 1no 2 yes
loan: 0unknow 1NO, 2 yes
contact: 0cellular 1 telephone
month: 1jan 2feb 3mar 4apr 5may 6jun 7jul 8aug 9sep 10oct 11nov 12dec
day_of_week: 1mon 2tue 3wed 4thu 5fri
poutcome: 1failure 2nonexistent 3success
y: 1no 2yes

```{r variables, echo=FALSE}
attach(dataSet)
#job
job_unk=which(job=='unknown')
job_adm=which(job=='admin.')
job_blu=which(job=='blue-collar')
job_entr=which(job=='entrepreneur')
job_hou=which(job=='housemaid')
job_man=which(job=='management')
job_ret=which(job=='retired')
job_sel=which(job=='self-employed')
job_ser=which(job=='services')
job_stu=which(job=='student')
job_tec=which(job=='technician')
job_une=which(job=='unemployed')

dataSet[job_unk,2]=0
dataSet[job_adm,2]=1
dataSet[job_blu,2]=2
dataSet[job_entr,2]=3
dataSet[job_hou,2]=4
dataSet[job_man,2]=5
dataSet[job_ret,2]=6
dataSet[job_sel,2]=7
dataSet[job_ser,2]=8
dataSet[job_stu,2]=9
dataSet[job_tec,2]=10
dataSet[job_une,2]=11


#marital
mar_unk=which(marital=='unknown')
mar_div=which(marital=='divorced')
mar_mar=which(marital=='married')
mar_sing=which(marital=='single')

dataSet[mar_unk,3]=0
dataSet[mar_div,3]=1
dataSet[mar_mar,3]=2
dataSet[mar_sing,3]=3


#education
ed_unk=which(education=='unknown')
ed_bas4=which(education=='basic.4y')
ed_bas6=which(education=='basic.6y')
ed_bas9=which(education=='basic.9y')
ed_hig=which(education=='high.school')
ed_ili=which(education=='illiterate')
ed_prof=which(education=='professional.course')
ed_uni=which(education=='university.degree')

dataSet[ed_unk,4]=0
dataSet[ed_bas4,4]=1
dataSet[ed_bas6,4]=2
dataSet[ed_bas9,4]=3
dataSet[ed_hig,4]=4
dataSet[ed_ili,4]=5
dataSet[ed_prof,4]=6
dataSet[ed_uni,4]=7


#default
def_un=which(default=='unknown')
def_no=which(default=='no')
def_yes=which(default=='yes')

dataSet[def_un,5]=0
dataSet[def_no,5]=1
dataSet[def_yes,5]=2


#housing
hos_un=which(housing=='unknown')
hos_no=which(housing=='no')
hos_yes=which(housing=='yes')

dataSet[hos_un,6]=0
dataSet[hos_no,6]=1
dataSet[hos_yes,6]=2


#loan
lo_un=which(loan=='unknown')
lo_no=which(loan=='no')
lo_yes=which(loan=='yes')

dataSet[lo_un,7]=0
dataSet[lo_no,7]=1
dataSet[lo_yes,7]=2


#contact
con_cel=which(contact=='cellular')
con_tel=which(contact=='telephone')

dataSet[con_cel,8]=0
dataSet[con_tel,8]=1

#month
mon_jan=which(month=='jan')
mon_feb=which(month=='feb')
mon_mar=which(month=='mar')
mon_apr=which(month=='apr')
mon_may=which(month=='may')
mon_jun=which(month=='jun')
mon_jul=which(month=='jul')
mon_aug=which(month=='aug')
mon_sep=which(month=='sep')
mon_oct=which(month=='oct')
mon_nov=which(month=='nov')
mon_dec=which(month=='dec')

dataSet[mon_jan,9]=1
dataSet[mon_feb,9]=2
dataSet[mon_mar,9]=3
dataSet[mon_apr,9]=4
dataSet[mon_may,9]=5
dataSet[mon_jun,9]=6
dataSet[mon_jul,9]=7
dataSet[mon_aug,9]=8
dataSet[mon_sep,9]=9
dataSet[mon_oct,9]=10
dataSet[mon_nov,9]=11
dataSet[mon_dec,9]=12


#day_of_week
day_mon=which(day_of_week=='mon')
day_tue=which(day_of_week=='tue')
day_wed=which(day_of_week=='wed')
day_thu=which(day_of_week=='thu')
day_fri=which(day_of_week=='fri')

dataSet[day_mon,10]=1
dataSet[day_tue,10]=2
dataSet[day_wed,10]=3
dataSet[day_thu,10]=4
dataSet[day_fri,10]=5


#poutcome
pou_fai=which(poutcome=='failure')
pou_non=which(poutcome=='nonexistent')
pou_suc=which(poutcome=='success')

dataSet[pou_fai,15]=1
dataSet[pou_non,15]=2
dataSet[pou_suc,15]=3

#y
y_no=which(y=='no')
y_yes=which(y=='yes')

dataSet[y_no,21]=1
dataSet[y_yes,21]=2
```




```{r particiones, echo=FALSE}
n_total = dim(dataSet)[1]
n_train = 0.1 * n_total # el 10% de la muestra se usa para entrenar los modelos
n_test = 0.1 * n_total #el 10% para test
n_validacion = n_total - n_train - n_test # el resto para la validación

indices_total = seq(1:n_total)
set.seed(12832)
indices_train = sample(indices_total,n_train)
indices_test = sample(indices_total[-indices_train],n_test)
indices_validation = indices_total[-c(indices_train,indices_test)]

dataSet_train = dataSet[indices_train,]
dataSet_test = dataSet[indices_test,]
dataSet_validation = dataSet[indices_validation,]
```


# Objetivos (del negocio)

Los datos de la base a tratar recogen multitud de información mediante las variables descritas anteriormente. Los datos pertenecen a la base de datos de un banco que está realizando campañas de marketing a sus clientes recogiendo así la información sobre ellos con el objetivo final de poder predecir si el cliente contactado abrirá un depósito a plazo en el banco o no lo hará. Por lo tanto, esa será nuestra variable respuesta "y", una variable de tipo binaria que tomará los valores de "sí" si el cliente abre un depósito a plazo en el banco, o "no" si no lo hace.

# Datos

# Preprocesado de datos.



## DAA. Exploratory Data Analysis.
En esta primera etapa, se va a estudiar posibles relaciones entre las distintas variables para así encontrar aquellas que aporten mayor información en el modelo.
Primeramente, se hace con las 5 primeras.

```{r scatter1, echo=FALSE}
library(psych)
attach(dataSet_train)

pairs.panels(dataSet_train[,1:5], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE # show correlation ellipses
             )
pairs.panels(dataSet_train[,c(1,5)], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE # show correlation ellipses
             )
plot(age,default)
```
En este primer gráfico se observa cierta importancia de la variable edad sobre el resto.
En el segundo se ve que los menos de 60 años son mas reacios a dar informacion de si tienen credito personal en incumplimiento o no



```{r scatter2, echo=FALSE}
pairs.panels(dataSet_train[,c(1,6,7,8,9)], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE # show correlation ellipses
             )
```


















```{r scatter3, echo=FALSE}
pairs.panels(dataSet_train[,c(1,10,11,12,13)], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE # show correlation ellipses
             )
```

```{r scatter4, echo=FALSE}
pairs.panels(dataSet_train[,c(1,14,15,16,17)], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE # show correlation ellipses
             )
```


















pairs(dataSet_train[,c(1,11)])
```{r eliminarColumna}
attach(dataSet_train)
duration = NULL
summary(duration)
```
```{r tiposDeDatos}
 sapply(dataSet_train, class)
 sapply(dataSet_train, mode)
```

```{r EDA}
attach(dataSet_train) 
summary(age)
hist(age)
table(age)
table(age<50)/dim(dataSet[1])*100
table(age<0,campaign)
table(age<50)/dim(dataSet[1])*100
table(age>0,campaign)
chisq.test(table(age,campaign))
##Nos interesa si es mayor o menor que 0.05
mean(dataSet[campaign==0,]$age)
#ggplot(data=dataSet, aes(age)) +
 # geom_density()+
  #ggtitle("Función de densidad de la variabel age")



```


## Correlación de las variables
Estudiamos la correlación entre las variabels explicativas y la variable respuesta
### Age:
```{r Corr, echo=FALSE}
  ggplot(data=dataSet, aes(x=age, fill=y))+
  geom_density(alpha=0.3)
```

Realizamos un contraste de hipótesis (t.test) para comprobar si hay diferencias significativas entre los dos puntos de interés:

```{r TEST_AGE}
#as.numeric(y)
#t.test(age-y)
```

Se puede concluir que la variable *Age es ...


### Duration
```{r CorrDur, echo=FALSE}
attach(dataSet_train)
hist(dataSet_train$duration) ##Aquí deberia dejar poenr solo duration
ggplot(data=dataSet, aes(x=duration, fill=y))+
  geom_density(alpha=0.3)
summary(dataSet_train$duration,dataSet_train$y)
chisq.test(table(dataSet_train$duration,dataSet_train$y))

```




## Transformación de variables 
Aparentemente hay valores o que  corresponden a mujeres que no se les tomó esta medida

```{r age_transformation}
hist(age)
age_cat= cut(age,c(-1,0.1,20,40,1000),labels=c("NS/NC","Bajo","Medio","Alto"))
table(age_cat,y)
chisq.test(table(age_cat,y))

```
Hemos transformado la variable, categorizándola en 4 niveles. La nueva variable resulta ser estadísticamente significativa. Es decir, es una variable que debemos teener en cuaneta e la construcción de los modelos de Machine Learning. 


```{r }
```






